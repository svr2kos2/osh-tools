//! Configuration management for osh-daemon
//!
//! Handles reading and writing daemon.toml configuration file.

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use uuid::Uuid;

/// Default config file name
const CONFIG_FILE: &str = "daemon.toml";

/// Daemon configuration stored in daemon.toml
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DaemonConfig {
    /// Server WebSocket URL
    pub server_url: String,
    /// Pre-shared secret key
    pub secret_key: String,
    /// Device ID (UUID, generated by init)
    pub device_id: String,
    /// Device name (defaults to hostname)
    pub device_name: String,
    /// Shell to use (optional, auto-detected if not set)
    #[serde(default)]
    pub shell: Option<String>,
}

impl DaemonConfig {
    /// Get the effective shell for this platform
    pub fn effective_shell(&self) -> String {
        if let Some(shell) = &self.shell {
            return shell.clone();
        }
        
        // Auto-detect shell
        Self::detect_shell()
    }
    
    /// Detect the default shell for the current platform
    pub fn detect_shell() -> String {
        #[cfg(target_os = "windows")]
        {
            "powershell".to_string()
        }
        #[cfg(not(target_os = "windows"))]
        {
            // Check for bash, fallback to sh
            if std::path::Path::new("/bin/bash").exists() {
                "bash".to_string()
            } else {
                "sh".to_string()
            }
        }
    }
    
    /// Get the current platform name
    pub fn platform() -> String {
        #[cfg(target_os = "windows")]
        {
            "windows".to_string()
        }
        #[cfg(target_os = "macos")]
        {
            "macos".to_string()
        }
        #[cfg(target_os = "linux")]
        {
            "linux".to_string()
        }
        #[cfg(not(any(target_os = "windows", target_os = "macos", target_os = "linux")))]
        {
            "unknown".to_string()
        }
    }
    
    /// Get the hostname
    pub fn hostname() -> String {
        hostname::get()
            .map(|s| s.to_string_lossy().to_string())
            .unwrap_or_else(|_| "unknown".to_string())
    }
}

/// Get the config file path
fn get_config_path() -> PathBuf {
    // Look for config in current directory first, then in user config dir
    let local_path = PathBuf::from(CONFIG_FILE);
    if local_path.exists() {
        return local_path;
    }
    
    // For cross-platform config directory
    if let Some(config_dir) = dirs::config_dir() {
        let app_config = config_dir.join("osh-daemon").join(CONFIG_FILE);
        if app_config.exists() {
            return app_config;
        }
    }
    
    // Default to current directory
    local_path
}

/// Load configuration from file
pub fn load_config() -> Result<DaemonConfig> {
    let path = get_config_path();
    let content = std::fs::read_to_string(&path)
        .with_context(|| format!("Failed to read config file: {}", path.display()))?;
    
    let config: DaemonConfig = toml::from_str(&content)
        .with_context(|| "Failed to parse config file")?;
    
    if config.device_id.is_empty() {
        anyhow::bail!("device_id is empty. Please run 'osh-daemon init' first.");
    }
    
    Ok(config)
}

/// Initialize a new configuration file
pub fn init_config(server: Option<String>, secret: Option<String>) -> Result<()> {
    let path = get_config_path();
    
    // Check if already exists
    if path.exists() {
        // Load existing config and show info
        let existing = std::fs::read_to_string(&path)?;
        let config: DaemonConfig = toml::from_str(&existing)?;
        println!("Configuration file already exists at: {}", path.display());
        println!("  device_id: {}", config.device_id);
        println!("  device_name: {}", config.device_name);
        println!("  server_url: {}", config.server_url);
        println!("\nTo reinitialize, delete the file first.");
        return Ok(());
    }
    
    // Create config directory if needed
    if let Some(parent) = path.parent() {
        if !parent.exists() {
            std::fs::create_dir_all(parent)?;
        }
    }
    
    // Generate new config
    let device_id = Uuid::new_v4().to_string();
    let device_name = DaemonConfig::hostname();
    
    let config = DaemonConfig {
        server_url: server.unwrap_or_else(|| "wss://example.com/bridge".to_string()),
        secret_key: secret.unwrap_or_else(|| "your-secret-key-here".to_string()),
        device_id: device_id.clone(),
        device_name: device_name.clone(),
        shell: None,
    };
    
    // Serialize to TOML with comments
    let content = format!(
r#"# OSH Daemon Configuration
# Generated by osh-daemon init

# Server WebSocket URL
server_url = "{}"

# Pre-shared secret key (must match server's devices.json)
secret_key = "{}"

# Device ID (auto-generated UUID, do not change)
device_id = "{}"

# Device name (defaults to hostname)
device_name = "{}"

# Shell to use (optional, auto-detected if not set)
# Windows: "powershell" or "cmd"
# Linux/macOS: "bash" or "sh"
# shell = "powershell"
"#,
        config.server_url,
        config.secret_key,
        config.device_id,
        config.device_name,
    );
    
    std::fs::write(&path, content)?;
    
    println!("Configuration initialized successfully!");
    println!("  Config file: {}", path.display());
    println!("  Device ID: {}", device_id);
    println!("  Device Name: {}", device_name);
    println!("  Platform: {}", DaemonConfig::platform());
    println!("  Shell: {}", DaemonConfig::detect_shell());
    println!("\nNext steps:");
    println!("  1. Edit {} to set server_url and secret_key", path.display());
    println!("  2. Run 'osh-daemon run' to start the daemon");
    
    Ok(())
}
